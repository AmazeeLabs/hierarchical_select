<?php
// $Id$

/**
 * @file
 * This module defines the "hierarchical_select" form element, which is a
 * greatly enhanced way for letting the user select an option in a hierarchy.
 * Out of the box, this module supports the taxonomy and content_taxonomy
 * modules, but that automatically includes the forum module. It also converts
 * any hierarchical taxonomy exposed filters in any View to a hierarchical
 * select.
 *
 * Any module that uses a select form element, of which the options are
 * ordered hierarchically, can take advantage of this new form element.
 * Especially when there's a deep hierarchy, or when there are a lot of
 * options in each sublevel, this form element greatly simplifies the user's
 * search for the right option.
 */


// Enable default support for some modules, if they are enabled.
if (module_exists('taxonomy')) {
  require_once drupal_get_path('module', 'hierarchical_select') .'/modules/taxonomy.inc';
}
if (module_exists('content_taxonomy')) {
  require_once drupal_get_path('module', 'hierarchical_select') .'/modules/content_taxonomy.inc';
}


//----------------------------------------------------------------------------
// Drupal core hooks.

/**
 * Implementation of hook_menu().
 */
function hierarchical_select_menu($may_cache) {
  if (!$maycache) {
    $items[] = array(
      'path' => 'hierarchical_select_ahah',
      'callback' => 'hierarchical_select_ahah',
      'access' => TRUE, // TODO: Check if this safe.
      'type' => MENU_CALLBACK,
    );
  }
  return $items;
}

/**
 * Implementation of hook_form_alter().
 */
function hierarchical_select_form_alter($form_id, &$form) {
  foreach (module_implements('hierarchical_select_form_alter') as $module) {
    $function = $module .'_hierarchical_select_form_alter';
    $function($form_id, $form);
  }
}

/**
 * Implementation of hook_elements().
 */
function hierarchical_select_elements() {
  $type['hierarchical_select'] = array(
    '#input' => TRUE, 
    '#process' => array('hierarchical_select_process' => array()),
    '#hierarchical_select_settings' => array(
      'save_lineage' => FALSE,
      'enforce_deepest' => FALSE,
      'level_labels' => array(),
      'params' => array(),
      'animationDelay' => 400,
    ),
    '#default_value' => -1,
  );
  return $type;
}


//----------------------------------------------------------------------------
// Menu callbacks.

/**
 * Menu callback; AHAH callback: generates and outputs the appropriate HTML.
 */
function hierarchical_select_ahah() {
  print _hierarchical_select_render(
    $_POST['hsid'],
    $_POST['module'],
    (!strstr($_POST['selection'], '|')) ? $_POST['selection'] : explode('|', $_POST['selection']),
    _hierarchical_select_str_to_bool($_POST['save_lineage']),
    _hierarchical_select_str_to_bool($_POST['enforce_deepest']),
    _hierarchical_select_str_to_bool($_POST['required']),
    explode('|', $_POST['level_labels']),
    unserialize($_POST['params'])
  );
  exit;
}


//----------------------------------------------------------------------------
// Forms API callbacks.

/**
 * Hierarchical select form element processing function.
 */
function hierarchical_select_process($element) {
  static $hsid;

  // Render a hierarchical select as a normal select, it's the JavaScript that
  // will turn it into a hierarchical select.
  $element['#type'] = 'select';

  if (!isset($hsid)) {
    $hsid = 0;

    $url = base_path();
    $url .= variable_get('clean_url', 0) ? '' : 'index.php?q=';
    $url .= 'hierarchical_select_ahah';

    // Add the CSS and JS, set the URL that should be used by all hierarchical
    // selects.
    drupal_add_css(drupal_get_path('module', 'hierarchical_select') .'/hierarchical_select.css');
    jquery_interface_add();
    drupal_add_js(drupal_get_path('module', 'hierarchical_select') .'/hierarchical_select.js');
    drupal_add_js(array('hierarchical_select' => array('url' => $url)), 'setting');
  }
  else {
    $hsid++;
  }

  // Extract settings.
  $module = $element['#hierarchical_select_settings']['module'];
  $enforce_deepest = (bool) $element['#hierarchical_select_settings']['enforce_deepest'];
  $save_lineage = (bool) $element['#hierarchical_select_settings']['save_lineage'];
  $required = (bool) $element['#required'];
  $level_labels = (array) $element['#hierarchical_select_settings']['level_labels'];
  $params = $element['#hierarchical_select_settings']['params'];
  $animation_delay = (int) $element['#hierarchical_select_settings']['animation_delay'];

  // When the #value property is empty, we're rendering this form (and thus
  // the form element) for the first time. When it's no longer empty, this
  // means that the validation failed and that we must keep the option that
  // was selected by the user.
  $selection = (empty($element['#value'])) ? $element['#value'] : $element['#default_value'];
  $selection = (is_array($selection)) ? array_reverse($selection) : $selection;
  
  $initial = _hierarchical_select_render($hsid, $module, $selection, $save_lineage, $enforce_deepest, $required, $level_labels, $params);

  drupal_add_js(
    array(
      'hierarchical_select' => array(
        'settings' => array(
          $hsid => array(
            'animationDelay' => ($animation_delay == 0) ? 400 : $animation_delay,
            'initial' => $initial,
            'module' => $module,
            'required' => $required,
            'enforceDeepest' => $enforce_deepest,
            'saveLineage' => $save_lineage,
            'levelLabels' => implode('|', $level_labels),
            'params' => serialize($params),
          ),
        ),
      )
    ),
    'setting'
  );

  // If the "save lineage" option is enabled, make the select a multiple select.
  if ($save_lineage) {
    $element['#multiple'] = TRUE;
  }

  // Set the unique class.
  $element['#attributes']['class'] .= " hierarchical-select hierarchical-select-$hsid";

  return $element;
}


//----------------------------------------------------------------------------
// Private functions.

/**
 * Render the hierarchical select.
 *
 * @param $hsid
 *   The HS id that should be used.
 * @param $module
 *   The module that should be used for HS hooks.
 * @param $selection
 *   The selection based on which a HS should be rendered.
 * @param $save_lineage
 *   Whether the "save lineage" option is enabled or not.
 * @param $enforce_deepest
 *   Whether the "enforce deepest" option is enabled or not.
 * @param $required
 *   Whether the form item is required or not.
 * @param $level_labels
 *   An array of labels, one per level. Optional.
 * @param $params
 *   An array of parameters, which may be necessary for some implementations.
 */
function _hierarchical_select_render($hsid, $module, $selection, $save_lineage = FALSE, $enforce_deepest = TRUE, $required = FALSE, $level_labels = array(), $params = array()) {
  $hierarchy = new StdClass();

  // Validate and clean up the selection.
  $selection = _hierarchical_select_validate_selection($selection, $module, $params);

  // Start building the hierarchy, initialize with the root level.
  $hierarchy->levels[0] = module_invoke($module, 'hierarchical_select_root_level', $params);

  // If the form item is optional, prepend a "none" option to the root level.
  if (!$required) {
    $hierarchy->levels[0] = array('none' => '<'. t('none') .'>') + $hierarchy->levels[0];
  }

  // If the "save lineage" option is enabled, then the selection *is* a
  // lineage. If it's disabled, we have to generate one ourselves based on the
  // (deepest) selected item.
  if ($save_lineage) {
    // When the form item is optional, and nothing is selected already, the
    // "none" option will be selected by default, thus only the first level
    // will be displayed. As a result, we won't receive an array as the
    // selection, but only a single item.
    $hierarchy->lineage = (is_array($selection)) ? $selection : array(0 => $selection);
  }
  else {
    if (module_invoke($module, 'hierarchical_select_valid_item', $selection, $params)) {
      $hierarchy->lineage = module_invoke($module, 'hierarchical_select_lineage', $selection, $params);
    }
    else {
      // If the selected item is invalid, then start with an empty lineage.
      $hierarchy->lineage = array();
    }
  }

  // If the lineage is empty and the "enforce deepest" option is ...
  // 1) ... disabled, then select the label of the first level by default.
  // 2) ... enabled, then select the first item in the root level by default. 
  if (empty($hierarchy->lineage)) {
    $hierarchy->lineage[0] = (!$enforce_deepest) ? 'label_0' : reset(array_keys($hierarchy->levels[0]));
  }

  // If we're enforcing a selection of an item in the deepest level in the
  // hierarchy (but still keeping the lineage of the current selection), we
  // have to pick items that will be selected by default in every level, and
  // add these to the lineage.
  if ($enforce_deepest && $hierarchy->lineage[0] != 'none') {
    $hierarchy->lineage = _hierarchial_select_enforce_deepest_selection($hierarchy->lineage, $hierarchy->levels[0], $module, $required, $params);
  }

  // Calculate the lineage's depth (starting from 0).
  $max_depth = count($hierarchy->lineage) - 1;

  // Build the rest of the hierarchy, based on the lineage.
  for ($depth = 1; $depth <= $max_depth; $depth++) {
    $hierarchy->levels[$depth] = module_invoke($module, 'hierarchical_select_children', $hierarchy->lineage[$depth - 1], $params);
  }

  // If the "enforce deepest" option is disabled ... 
  if (!$enforce_deepest) {
    // ... we have to prepend labels to every level ...
    for ($depth = 0; $depth <= $max_depth; $depth++) {
      $hierarchy->levels[$depth] = array('label_'. $depth => $level_labels[$depth]) + $hierarchy->levels[$depth];
    }

    // ... and have to add one more level if appropriate.
    $parent = $hierarchy->lineage[$max_depth];
    if (module_invoke($module, 'hierarchical_select_valid_item', $parent, $params)) {
      $children = module_invoke($module, 'hierarchical_select_children', $parent, $params);
      if (count($children)) {
        // We're good, let's add one level!
        $max_depth++;
        $first_child = reset(array_keys($children));
        $hierarchy->lineage[$max_depth] = 'label_'. $max_depth;
        $hierarchy->levels[$max_depth] = array('label_'. $max_depth => $level_labels[$max_depth]) + $children;
      }
    }
  }

  return _hierarchical_select_render_selects($hsid, $hierarchy);
}

/**
 * Helper function to update the lineage of the hierarchy to ensure that the
 * user selects an item in the deepest level of the hierarchy.
 *
 * @param $lineage
 *   The lineage up to the deepest selection the user has made so far.
 * @param $root_level
 *   The options in the root level.
 * @param $module
 *   The module that should be used for HS hooks.
 * @param $required
 *   Boolean, whether the form item is required or not.
 * @param $params
 *   The params that should be passed to HS hooks.
 * @return
 *   The updated lineage.
 */
function _hierarchial_select_enforce_deepest_selection($lineage, $root_level, $module, $required, $params) {
  // Use the deepest item as the first parent. Then apply this algorithm:
  // 1) get the parent's children, stop if no children
  // 2) choose the first child as the option that is selected by default, by
  //    adding it to the lineage of the hierarchy
  // 3) make this child the parent, go to step 1.
  $parent = end($lineage); // The last item in the lineage is the deepest one.
  $children = module_invoke($module, 'hierarchical_select_children', $parent, $params);
  while (count($children)) {
    $first_child = reset(array_keys($children));
    $lineage[] = $first_child;
    $parent = $first_child;
    $children = module_invoke($module, 'hierarchical_select_children', $parent, $params);
  }

  return $lineage;
}

/**
 * Reset the selection if no valid item was selected. If an array is passed
 * (this happens when the "save lineage" option is enabled), then the first
 * item in the array corresponds to the first selected term. As soon as an
 * invalid item is encountered, the lineage from that level to the deeper
 * levels should be unset. This is so to ignore selection of a level label.
 *
 * @param $selection
 *   Either a single item id or an array of item ids.
 * @param $module
 *   The module that should be used for HS hooks.
 * @param $params
 *   The module that should be passed to HS hooks.
 * @return
 *   The updated selection.
 */
function _hierarchical_select_validate_selection($selection, $module, $params) {
  // Reset if no item was selected or the item's id could not be validated.
  if (is_array($selection)) {
    // The "save lineage" option is enabled because $selection is an array.
    $valid = TRUE;
    for ($i = 0; $i < count($selection); $i++) {
      if ($valid) {
        $valid = module_invoke($module, 'hierarchical_select_valid_item', $selection[$i], $params);
      }
      if (!$valid) {
        unset($selection[$i]);
      }
    }
  }
  elseif ($selection != 'none' && !module_invoke($module, 'hierarchical_select_valid_item', $selection, $params)) {
    $selection = -1;
  }
  return $selection;
}

/**
 * Render the HTML (the selects) for the given hierarchy..
 *
 * @param $hsid
 *   The hierarchical select id.
 * @param $hierarchy
 *   A hierarchy object.
 * @return
 *   The rendered HTML.
 */
function _hierarchical_select_render_selects($hsid, $hierarchy) {
  $output = '';

  for ($depth = 0; $depth < count($hierarchy->lineage); $depth++) {
    $output .= '<select id="hierarchical-select-'. $hsid .'-level-'. $depth .'" class="form-select hierarchical-select hierarchical-select-'. $hsid .'-hierarchical-select">';
    foreach ($hierarchy->levels[$depth] as $value => $label) {
      if ($value == $hierarchy->lineage[$depth]) {
        $output .= '<option selected="selected" value="'. check_plain($value) .'">'. check_plain($label) .'</option>';
      }
      else {
        $output .= '<option value="'. check_plain($value) .'">'. check_plain($label) .'</option>';
      }
    }
    $output .= '</select>';
  }

  return $output;
}

/**
 * Helper function that adds the JS to reposition the exposed filters of a
 * View just once.
 */
function _hierarchical_select_views_exposed_filters_reposition() {
  static $js_added;
  
  if (!isset($js_added)) {
    drupal_add_js(drupal_get_path('module', 'hierarchical_select') .'/modules/views.js', 'module');
  }
}

/**
 * Convert a "true" or "false" string into the corresponding boolean value,
 * while ignoring the case.
 *
 * @param $string
 *   The string to convert.
 * @return
 *   The boolean value.
 */
function _hierarchical_select_str_to_bool($string) {
  return (strcasecmp($string, 'TRUE') == 0);
}
