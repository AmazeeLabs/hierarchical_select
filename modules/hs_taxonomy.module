<?php
// $Id$


require_once(drupal_get_path('module', 'hierarchical_select') .'/includes/common.inc');


//----------------------------------------------------------------------------
// Hierarchical Select hooks.

/**
 * Implementation of hook_hierarchical_select_form_alter().
 */
function hs_taxonomy_hierarchical_select_form_alter($form_id, &$form) {
  // Add per-vocabulary settings for Hierarchical Select.
  if ($form_id == 'taxonomy_form_vocabulary') {
    drupal_add_js(drupal_get_path('module', 'hs_taxonomy') .'/hs_taxonomy.js', 'module');

    $vid = $form['vid']['#value'];
    $first_part = array_slice($form, 0, 10);
    $second_part = array_slice($form, 10);
    $form = $first_part;

    $form['hierarchical_select_status'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use the Hierarchical Select form element for this vocabulary.'),
      '#default_value' => variable_get("taxonomy_hierarchical_select_$vid", 0),
    );

    // Add the Hierarchical Select config form.
    $module = 'hs_taxonomy';
    $params = array('vid' => $vid);
    $config_id = "taxonomy-$vid";
    $vocabulary = taxonomy_get_vocabulary($vid);
    $defaults = array(
      // Enable the save_lineage setting by default if the multiple parents
      // vocabulary option is enabled.
      'save_lineage' => (int) ($vocabulary->hierarchy == 2),
      'editability' => array(
        'max_levels' => _hs_taxonomy_hierarchical_select_get_depth($vid),
      ),
    );
    $strings = array(
      'hierarchy'   => t('vocabulary'),
      'hierarchies' => t('vocabularies'),
      'item'        => t('term'),
      'items'       => t('terms'),
      'item_type'   => t('term type'),
    );
    $max_hierarchy_depth = _hs_taxonomy_hierarchical_select_get_depth($vid);
    $preview_is_required = $vocabulary->required;
    $form['hierarchical_select'] = hierarchical_select_common_config_form($module, $params, $config_id, $defaults, $strings, $max_hierarchy_depth, $preview_is_required);

    // Add the the submit handler for the Hierarchical Select config form.
    $parents = array('hierarchical_select');
    $form['#submit']['hierarchical_select_common_config_form_submit'] = array($parents);

    // Add a validate callback to override the freetagging and multiple select
    // settings if necessary.
    $form['#validate']['hierarchical_select_taxonomy_form_vocabulary_validate'] = array();
    $form['#submit']['hierarchical_select_taxonomy_form_vocabulary_submit'] = array();

    // The original #submit callback(s) has/have to be executed afterwards.
    $form['#submit'] = array_merge($form['#submit'], $second_part['#submit']);

    $form += $second_part;
  }

  // Change the term selection of nodes. Only affects hierarchical
  // vocabularies.
  if (isset($form['type']) && $form['type']['#value'] .'_node_form' == $form_id && is_array($form['taxonomy'])) {
    foreach ($form['taxonomy'] as $vid => $form_item) {

      // Only apply Hierarchical Select if it's enabled for this vocabulary.
      if (is_numeric($vid) && variable_get("taxonomy_hierarchical_select_$vid", 0)) {
        $vocabulary = taxonomy_get_vocabulary($vid);

        // Hierarchical Select only makes sense if there's a hierarchy.
        if ($vocabulary->hierarchy > 0) {
          // #size is set as soon as save_lineage or the dropbox is enabled,
          // because then "multiple select" is enabled. Unset #size.
          unset($form['taxonomy'][$vid]['#size']);

          $form['taxonomy'][$vid]['#type'] = 'hierarchical_select';
          $form['taxonomy'][$vid]['#config'] = array(
            'module' => 'hs_taxonomy',
            'params' => array(
              'vid' => $vid,
            ),
          );
          hs_taxonomy_hierarchical_select_update_form_item($form['taxonomy'][$vid], $vid);
        }
      }
    }
  }
}

/**
 * Implementation of hook_hierarchical_select_params().
 */
function hs_taxonomy_hierarchical_select_params() {
  $params = array(
    'vid',
  );
  return $params;
}

/**
 * Implementation of hook_hierarchical_select_root_level().
 */
function hs_taxonomy_hierarchical_select_root_level($params) {
  $terms = _hs_taxonomy_hierarchical_select_get_tree($params['vid'], 0, -1, 1);
  return _hs_taxonomy_hierarchical_select_terms_to_options($terms);
}

/**
 * Implementation of hook_hierarchical_select_children().
 */
function hs_taxonomy_hierarchical_select_children($parent, $params) {
  $terms = taxonomy_get_children($parent, $params['vid']);
  return _hs_taxonomy_hierarchical_select_terms_to_options($terms);
}

/**
 * Implementation of hook_hierarchical_select_lineage().
 */
function hs_taxonomy_hierarchical_select_lineage($item, $params) {
  $lineage = array();

  $terms = array_reverse(taxonomy_get_parents_all($item));
  foreach ($terms as $term) {
    $lineage[] = $term->tid;
  }
  return $lineage;
}

/**
 * Implementation of hook_hierarchical_select_valid_item().
 */
function hs_taxonomy_hierarchical_select_valid_item($item, $params) {
  if (!is_numeric($item) || $item < 1) {
    return FALSE;
  }
  $term = taxonomy_get_term($item);
  return ($term->vid == $params['vid']);
}

/**
 * Implementation of hook_hierarchical_select_item_get_label().
 */
function hs_taxonomy_hierarchical_select_item_get_label($item, $params) {
  static $labels = array();
  
  if (!isset($labels[$item])) {
    $term = taxonomy_get_term($item);
    // Use the translated term when available!
    $labels[$item] = t($term->name);
  }

  return $labels[$item];
}


/**
 * Implementation of hook_hierarchical_select_create_item().
 */
function hs_taxonomy_hierarchical_select_create_item($label, $parent, $params) {
  $form_values = array(
    'name'   => $label,
    'parent' => $parent,
    'vid'    => $params['vid'],
  );
  $status = taxonomy_save_term($form_values);
  
  if ($status == SAVED_NEW) {
    // Reset the cached tree.
    _hs_taxonomy_hierarchical_select_get_tree($params['vid'], 0, -1, 1, TRUE);

    // Retrieve the tid.
    $children = taxonomy_get_children($parent, $params['vid']);
    foreach ($children as $tid => $term) {
      if ($term->name == $label) {
        return $tid;
      }
    }
  }
  else {
    return FALSE;
  }
}

/**
 * Implementation of hook_hierarchical_select_node_count().
 */
function hs_taxonomy_hierarchical_select_node_count($item, $params) {
  return hs_taxonomy_term_count_nodes($item);
}

/**
 * Implementation of hook_hierarchical_select_implementation_info().
 */
function hs_taxonomy_hierarchical_select_implementation_info() {
  return array(
    'hierarchy type' => t('Taxonomy'),
    'entity type'    => t('Node'),
  );
}

/**
 * Implementation of hook_hierarchical_select_config_info().
 */
function hs_taxonomy_hierarchical_select_config_info() {
  static $config_info;

  if (!isset($config_info)) {
    $config_info = array();

    $content_types = node_get_types();
    $vocabularies = taxonomy_get_vocabularies();

    foreach ($vocabularies as $vid => $vocabulary) {
      if (variable_get("taxonomy_hierarchical_select_$vid", 0)) {
        // Collect the human-readable names of each content type for which this
        // vocabulary is used.
        $entities = array();
        foreach ($vocabulary->nodes as $content_type) {
          $entities[] = $content_types[$content_type]->name;
        }

        $config_id = "taxonomy-$vid";
        $config_info[$config_id] = array(
          'config_id'      => $config_id,
          'hierarchy type' => t('Taxonomy'),
          'hierarchy'      => t($vocabulary->name),
          'entity type'    => t('Node'),
          'entity'         => implode(', ', array_map('t', $entities)),
          'edit link'      => "admin/content/taxonomy/edit/vocabulary/$vid",
        );
      }
    }
  }

  return  $config_info;
}


//----------------------------------------------------------------------------
// FAPI callbacks.

/**
 * Additional validate callback for the taxonomy_form_vocabulary form.
 */
function hierarchical_select_taxonomy_form_vocabulary_validate($form_id, $form_values, $form) {
  // Enable Taxonomy's "multiple select" setting when:
  // - Hierarchical Select's "multiple select" setting is enabled
  // - Hierarchical Select's "save term lineage" setting is enabled
  $multiple_select_enabled = ($form_values['hierarchical_select']['dropbox']['status'] || $form_values['hierarchical_select']['save_lineage']);
  form_set_value($form['multiple'], (int) $multiple_select_enabled);

  // If Hierarchical Select is enabled, disable freetagging.
  if ($form_values['hierarchical_select']['status']) {
    form_set_value($form['tags'], 0);
  }
}

/**
 * Additional submit callback for the taxonomy_form_vocabulary form.
 */
function hierarchical_select_taxonomy_form_vocabulary_submit($form_id, $form_values) {
  $vid = $form_values['vid'];
  variable_set("taxonomy_hierarchical_select_$vid", $form_values['hierarchical_select_status']);
}


//----------------------------------------------------------------------------
// Private functions.

/**
 * Drupal core's taxonomy_get_tree() doesn't allow us to reset the cached
 * trees, which obviously causes problems when you create new items between
 * two calls to it.
 */
function _hs_taxonomy_hierarchical_select_get_tree($vid, $parent = 0, $depth = -1, $max_depth = NULL, $reset = FALSE) {
  static $children, $parents, $terms;

  if ($reset) {
    $children = $parents = $terms = array();
  }

  $depth++;

  // We cache trees, so it's not CPU-intensive to call get_tree() on a term
  // and its children, too.
  if (!isset($children[$vid])) {
    $children[$vid] = array();

    $result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {term_data} t INNER JOIN  {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $vid);
    while ($term = db_fetch_object($result)) {
      $children[$vid][$term->parent][] = $term->tid;
      $parents[$vid][$term->tid][] = $term->parent;
      $terms[$vid][$term->tid] = $term;
    }
  }

  $max_depth = (is_null($max_depth)) ? count($children[$vid]) : $max_depth;
  if ($children[$vid][$parent]) {
    foreach ($children[$vid][$parent] as $child) {
      if ($max_depth > $depth) {
        $term = drupal_clone($terms[$vid][$child]);
        $term->depth = $depth;
        // The "parent" attribute is not useful, as it would show one parent only.
        unset($term->parent);
        $term->parents = $parents[$vid][$child];
        $tree[] = $term;

        if ($children[$vid][$child]) {
          $tree = array_merge($tree, _hs_taxonomy_hierarchical_select_get_tree($vid, $child, $depth, $max_depth));
        }
      }
    }
  }

  return $tree ? $tree : array();
}

/**
 * Drupal core's taxonomy_term_count_nodes() is buggy. See
 * http://drupal.org/node/144969#comment-843000.
 */
function hs_taxonomy_term_count_nodes($tid, $type = 0) {
  static $count;

  $term = taxonomy_get_term($tid);
  $tree = _hs_taxonomy_hierarchical_select_get_tree($term->vid, $tid);
  $tids = array($tid);
  foreach ($tree as $descendant) {
    $tids[] = $descendant->tid;
  }

  if (!isset($count[$type][$tid])) {
    if (is_numeric($type)) {
      $count[$type][$tid] = db_result(db_query(db_rewrite_sql("SELECT COUNT(DISTINCT(n.nid)) AS count FROM {term_node} t INNER JOIN {node} n ON t.nid = n.nid WHERE n.status = 1 AND t.tid IN (%s)"), implode(',', $tids)));
    }
    else {
      $count[$type][$tid] = db_result(db_query(db_rewrite_sql("SELECT COUNT(DISTINCT(n.nid)) AS count FROM {term_node} t INNER JOIN {node} n ON t.nid = n.nid WHERE n.status = 1 AND n.type = '%s' AND t.tid IN (%s)"), $type, implode(',', $tids)));
    }
  }
  return $count[$type][$tid];
}

/**
 * Transform an array of terms into an associative array of options, for use
 * in a select form item.
 *
 * @param $terms
 *  An array of term objects.
 * @return
 *  An associative array of options, keys are tids, values are term names.
 */
function _hs_taxonomy_hierarchical_select_terms_to_options($terms) {
  $options = array();
  foreach ($terms as $key => $term) {
    // Use the translated term when available!
    $options[$term->tid] = t($term->name);
  }
  return $options;
}

/**
 * Get the depth of a vocabulary's tree.
 *
 * @param $vid
 *   A vocabulary id.
 * @return
 *   The depth of the vocabulary's tree.
 */
function _hs_taxonomy_hierarchical_select_get_depth($vid) {
  $tree = _hs_taxonomy_hierarchical_select_get_tree($vid);
  foreach ($tree as $term) {
    if ($term->depth > $depth) {
      $depth = $term->depth;
    }
  }
  return $depth;
}

/**
 * Update a taxonomy select to become a hierarchical_select type form item.
 *
 * @param $form_item
 *   The form item to update.
 * @param $vid
 *   The id of the vocabulary of which the configuration should be applied.
 */
function hs_taxonomy_hierarchical_select_update_form_item(&$form_item, $vid) {
  unset($form_item['#options']); // Unset to prevent passing around of possibly huge HTML.
  unset($form_item['#theme']);   // Unset to prevent theme_taxonomy_term_select() from running.

  hierarchical_select_common_config_apply($form_item, "taxonomy-$vid");
}
